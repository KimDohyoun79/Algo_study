# 완전 탐색(Exhaustive Search)
- Brute : **단순히, 순전히**
- Force : **힘**
- 단순히 힘으로 푼다. ⇒ 머리는 쓰지 않고 모든 것을 다 해보겠다는 의미한다.
- 완전 탐색은 컴퓨터의 빠른 계산 성능을 활용하여 가능한 모든 경우의 수를 탐색하는 방법
- `시간 & 효율성` ↓ `정확성`↑

<br>

--- 

## 추가 설명
가능한 모든 경우의 수를 전부 체크하여 정답을 찾는 방법으로 존재하는 모든 답을 하나씩 검사하기 때문에, 소요되는 시간은 답의 갯수에 정확히 비례한다. 따라서 문제의 최대 입력 크기를 가정했을 때 답의 갯수를 계산해보고, 이들 전부를 제한 시간 안에 생성할 수 있을지를 확인해야 한다.

- <h3>장점</h3>
   - 반드시 답을 찾을 수 있다는 것 => 최소한 1개 이상의 답을 찾아낸다.
   - 모든 경우의 수를 확인해도 답이 없다면 답이 없다는 것을 찾아낸 것이 답!

- <h3>단점</h3>
   - 당연히 모든 것을 봐야 하기 효율이 떨진다. ⇒ (적합성을 고려 필요)
   - 때문에 오래 걸린다는 것이 단점.  => (시간초과)

<br/>

---
## 완전 탐색 종류


<h3 id="sec-01-01">1. Brute-Force</h3>
- 반복문, 조건문을 활용하여 단순하게 모든 방법을 찾아 답을 구하는 방법


<br/>


<h3 id="sec-01-05">2. 순열</h3>
- 완전 탐색의 대표적인 유형. 
- 임의의 수열이 있을 때, 이를 다른 순서로 연산하는 방법.
- 서로 다른 N개의 원소를 일렬로 나열하는 순열의 경우의 수는 `N!`으로, 시간 복잡도가 매우 높다. 
- 따라서 완전 탐색을 코딩 테스트에서 이용하기 위해서는 N이 1자리 수 정도가 되어야 함.


<br/>


<h3 id="sec-01-03">3. 재귀 함수</h3>
- 문제를 해결하기 위한 방법을 모두 탐색하기 위해 재귀 함수를 통해 문제를 만족하는 경우들을 재귀적으로 만들어가는 방법. 


<br/>


<h3 id="sec-01-02">4. 비트 마스크(Bitmask)</h3>
- 비트 연산을 통해 부분집합을 표현하는 방법. 
- 문제에서 나올 수 있는 모든 경우의 수가 각각의 원소가 포함되거나, 포함되지 않는 두가지 선택으로 구성되는 경우 유용하게 활용 가능.


<br/>


<h3 id="sec-01-06">5. DFS/BFS</h3>
- 그래프 자료구조의 모든 정점을 탐색하는 방법.

<br/>
